#!/usr/bin/env ruby

require 'scout'

$0 = "scout #{$previous_commands.any? ? $previous_commands*" " + " " : "" }#{ File.basename(__FILE__) }" if $previous_commands

ENV["SCOUT_NO_STREAM"] = "true" if ARGV.include? "--nostream"
ARGV.delete '--nostream'
ENV["SCOUT_UPDATE"] = "true" if ARGV.include? "--update"
ARGV.delete '--update'

options = SOPT.setup <<EOF

Run a workflow job

$ #{$0} [<options>] <workflow> <task>

-h--help Print this help
--workflows* Other workflows to load
--nostream Disable job streaming
--update Update jobs with newer dependencies
--deploy* Deploy mode: serial, local, queue, or SLURM (default 'serial')
--deploy_rules* Deployment rules; can be files of keywords
--fork Fork and return path
--exec Exec and return output
--load_inputs* Directory or file with inputs files to load
--save_inputs* Directory or tar.gz file path to store inputs
-jn--jobname* Name to use as job identifier
-pf--printpath Print the file path
-prov--provenance Print the step provenance
-cl--clean Clean the last step
-rcl--recursive_clean Clean all steps
-ct--clean_task* Clean a particular task
-od--override_deps* Override deps using 'Workflow#task=<path>' array_separated
EOF

workflow_name, task_name = ARGV


help, workflows, provenance, clean, recursive_clean, clean_task, load_inputs, save_inputs, jobname, printpath, deploy, deploy_rules, override_deps, do_fork, do_exec = IndiferentHash.process_options options,
  :help, :workflows, :provenance, :clean, :recursive_clean, :clean_task, :load_inputs, :save_inputs, :jobname, :printpath, :deploy, :deploy_rules, :override_deps, :fork, :exec,
  :deploy => 'serial'

raise MissingParameterException.new :workflow if workflow_name.nil?

workflow = Workflow.require_workflow workflow_name

workflows = workflows.split(/,\s*/) if workflows
workflows.each{|wf| Workflow.require_workflow wf } if workflows

task_name = task_name.to_sym if task_name
task = workflow.tasks[task_name.to_sym] if task_name

help = true if task.nil?

if help
  if defined? scout_usage
    scout_usage
  else
    puts SOPT.doc
  end

  puts workflow.usage(task) if workflow

  if task_name && task.nil?
    exit -1
  else
    exit 0
  end
end

task = workflow.tasks[task_name]

job_inputs = task.get_SOPT

if load_inputs
  job_inputs = job_inputs.merge(task.load_inputs(load_inputs))
end

if override_deps
  override_deps.split($array_separator || ",").each do |part|
    t_, value = part.split("=")
    job_inputs.merge!( t_ => value)
  end
end

job = workflow.job(task_name, jobname, job_inputs)

job.recursive_clean if recursive_clean
job.clean if clean

if clean_task 
  ENV["SCOUT_UPDATE"] = 'true'
  clean_task.split(",").each do |clean_task|
    if clean_task.include? "#"
      clean_workflow, clean_task = clean_task.split("#")
    end

    job.rec_dependencies.each do |dep|
      next unless dep.task_name.to_s == clean_task.to_s
      next unless clean_workflow.nil? || clean_workflow == dep.workflow.to_s
      dep.clean 
      dep.set_info :status, :cleaned
    end

    job.clean if (job.task_name.to_s == clean_task.to_s) || ! job.updated?
  end
end

if provenance
  puts Step.prov_report(job)

elsif do_fork
  job.fork
  puts job.path
  exit 0
elsif do_exec
  puts job.exec
  exit 0
elsif save_inputs
  puts job.save_inputs(save_inputs)
  exit 0
else
  require 'scout/workflow/deployment'

  if deploy_rules.nil?
    deploy_files = [:default]
    deploy_files << workflow.to_s
    deploy_files += workflows if workflows
  else
    deploy_files = deploy_rules.split(/,\s*/)
  end

  case deploy
  when "queue"
    if ! job.done?
      save_inputs = Scout.var.queue[workflow.to_s][task_name][job.name].find
      job.save_inputs(save_inputs)
      puts save_inputs
      exit
    end
  when 'dry', 'dryrun', 'debug'
    rules = Workflow::Orchestrator.load_rules deploy_files
    batches = Workflow::Orchestrator.job_batches rules, job
    batches.each do |batch|
      top = batch[:top_level]
      puts Log.color :title, Log.fingerprint(top)
      puts batch[:rules].to_yaml
      deps = batch[:deps].collect{|dep| dep[:top_level] }
      other = batch[:jobs] - [top]
      puts Log.color :subtitle, 'Other jobs: ' + Log.color(:blue, other.collect{|d| d.short_path}.uniq * ', ' ) if other.any?
      puts Log.color :subtitle, 'Dependencies: ' + Log.color(:blue, deps.collect{|d| d.short_path}.uniq * ', ' ) if deps.any?
    end
  when "serial"
    job.run(true) 
  when "local"
    rules = Workflow::Orchestrator.load_rules deploy_files
    Workflow::LocalExecutor.produce job, rules
  when "slurm"
    rules = Workflow::Orchestrator.load_rules deploy_files
    Workflow::Scheduler.produce job, rules
  else
    if deploy.end_with?('-slurm')
      server = deploy.sub('-slurm','')
      OffsiteStep.setup(job, server: server, slurm: true)
    else
      OffsiteStep.setup(job, server: deploy)
    end

    job.run
  end unless job.done?

  if printpath
    job.join
    path = job.path
    path = path.find if Path === path
    puts path
  else
    if ! ((c = Open.consume_stream(job.stream, false, STDOUT, false)) && c.end_with?("\n"))
      puts
    end
  end
end
